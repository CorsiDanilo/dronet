from __future__ import annotations
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from src.simulation.simulator import Simulator
    from src.entities.uav_entities import Drone, Depot

import numpy as np
from src.utilities import config, utilities, printer




class SimulatedEntity:
    """ A simulated entity keeps track of the simulation object, where you can access all the parameters
    of the simulation. No class of this type is directly instantiable.
    """

    def __init__(self, simulator):
        self.simulator: Simulator = simulator


# ------------------ Entities ----------------------
class Entity(SimulatedEntity):
    """ An entity in the environment, e.g. Drone, Event, Packet. It extends SimulatedEntity. """

    def __init__(self, identifier: int, coords: tuple, simulator):
        super().__init__(simulator)
        self.identifier = identifier  # the id of the entity
        self.coords = coords  # the coordinates of the entity on the map

    def __eq__(self, other):
        """ Entity objects are identified by their id. """
        if not isinstance(other, Entity):
            return False
        else:
            return other.identifier == self.identifier

    def __hash__(self):
        return hash((self.identifier, self.coords))


# ------------------ Event -----------------------
# Created in feel_event, not a big deal
class Event(Entity):
    """ An event is any kind of event that the drone detects on the aoi. It is an Entity. """

    def __init__(self, coords: tuple, current_time: int, simulator, deadline=None):
        super().__init__(id(self), coords, simulator)
        self.current_time = current_time

        # One can specify the deadline or just consider as deadline now + EVENTS_DURATION
        # The deadline of an event represents the estimate of the drone that the event will be no more
        # interesting to monitor.
        self.deadline = current_time + self.simulator.event_duration if deadline is None else deadline

        # add metrics: all the events generated during the simulation
        # GENERATED_EVENTS
        if not coords == (-1, -1) and not current_time == -1:
            self.simulator.metrics.events.add(self)

    def to_json(self):
        """ return the json repr of the obj """
        return {"coord": self.coords,
                "i_gen": self.current_time,
                "i_dead": self.deadline,
                "id": self.identifier
                }

    def is_expired(self, cur_step):
        """ return true if the deadline expired """
        return cur_step > self.deadline

    def as_packet(self, time_step_creation, drone):
        """ build a packet out of the event, by default the packet has deadline set to that of the event
            so the packet dies at the same time of the event, then add the input drone as first hop
        """
        # Notice: called only when a packet is created

        pck = DataPacket(time_step_creation, self.simulator, event_ref=self)
        # if config.DEBUG_PRINT_PACKETS: print("data", pck, pck.src_drone, pck.dst_drone, self.current_time)
        pck.add_hop(drone)
        return pck

    def __repr__(self):
        return "Ev id:" + str(self.identifier) + " c:" + str(self.coords)


# ------------------ Packet ----------------------
class Packet(Entity):
    """ A packet is an object created out of an event monitored on the aoi. """

    def __init__(self, time_step_creation, simulator, event_ref: Event = None):
        """ the event associated to the packet, time step in which the packet was created
         as for now, every packet is an event. """

        event_ref_crafted = event_ref if event_ref is not None else Event((-1, -1), -1,
                                                                          simulator)  # default event if packet is not associated to the event

        # id(self) is the id of this instance (unique for every new created packet),
        # the coordinates are those of the event
        super().__init__(id(self), event_ref_crafted.coords, simulator)

        self.time_step_creation = time_step_creation
        self.event_ref = event_ref_crafted
        self.__TTL = -1  # TTL is the number of hops that the packet crossed
        self.__max_TTL = self.simulator.packets_max_ttl
        self.number_retransmission_attempt = 0

        # self.hops = set()  # All the drones that have received/transmitted the packets
        self.last_2_hops = []
        # add metrics: all the packets generated by the drones, either delivered or not (union of all the buffers)
        if event_ref is not None:
            self.add = self.simulator.metrics.drones_packets.add(self)

        self.optional_data = None  # list
        self.time_delivery = None

        # if the packet was sent with move routing or not
        self.is_move_packet = None

    def distance_from_depot(self):
        return utilities.euclidean_distance(self.simulator.depot_coordinates, self.coords)

    def age_of_packet(self, cur_step):
        return cur_step - self.time_step_creation

    def to_json(self):
        """ return the json repr of the obj """

        return {"coord": self.coords,
                "i_gen": self.time_step_creation,
                "i_dead": self.event_ref.deadline,
                "id": self.identifier,
                "TTL": self.__TTL,
                "id_event": self.event_ref.identifier}

    def add_hop(self, drone):
        """ add a new hop in the packet """

        if len(self.last_2_hops) == 2:
            self.last_2_hops = self.last_2_hops[1:]  # keep just the last two HOPS
        self.last_2_hops.append(drone)

        # self.hops.add(drone.identifier)
        self.increase_TTL_hops()

    def increase_TTL_hops(self):
        self.__TTL += 1

    def increase_transmission_attempt(self):
        self.number_retransmission_attempt += 1

    def is_expired(self, cur_step):
        """ a packet expires if the deadline of the event expires, or the maximum TTL is reached """
        return cur_step > self.event_ref.deadline

    def __repr__(self):
        packet_type = str(self.__class__).split(".")[-1].split("'")[0]
        return packet_type + "id:" + str(self.identifier) + " event id: " + str(
            self.event_ref.identifier) + " c:" + str(self.coords)

    def append_optional_data(self, data):
        """ append optional data in the hello message to share with neigh drones infos """
        self.optional_data = data


class DataPacket(Packet):
    """ Basically a Packet"""

    def __init__(self, time_step_creation, simulator, event_ref: Event = None):
        super().__init__(time_step_creation, simulator, event_ref)


class ACKPacket(Packet):
    def __init__(self, src_drone, dst_drone, simulator, acked_packet, time_step_creation=None):
        super().__init__(time_step_creation, simulator, None)
        self.acked_packet = acked_packet  # packet that the drone who creates it wants to ACK

        # source and destination of a packet
        self.src_drone = src_drone
        self.dst_drone = dst_drone


class HelloPacket(Packet):
    """ The hello message is responsible to give info about neighborhood """
    def __init__(self, src_drone, time_step_creation, simulator, cur_pos, speed, next_target):
        super().__init__(time_step_creation, simulator, None)
        self.cur_pos = cur_pos
        self.speed = speed
        self.next_target = next_target
        self.src_drone = src_drone  # Don't use this

class DiscoveryPacket(Packet):
    def __init__(self, entity, simulator, hop_count = 1):
        super().__init__(simulator.cur_step, simulator, None)
        self.entity = entity
        self.hop_count = hop_count
    
    def __repr__(self):
        return f"Sender: {self.entity}, hop_count: {self.hop_count}"


class AckDiscoveryPacket(Packet): 
    def __init__(self, sender_id, self_id, self_moving_speed, self_location, hop_count, simulator):
        super().__init__(simulator.cur_step, simulator, None)
        self.sender_id = sender_id
        self.self_id = self_id
        self.self_moving_speed = self_moving_speed
        self.self_location = self_location
        self.hop_count = hop_count

# --------------- Nodes Table -------------------
class NodeInfo():
    def __init__(self, self_id, self_moving_speed, self_location, hop_count):
        self.self_id = self_id
        self.self_moving_speed = self_moving_speed
        self.self_location = self_location
        self.hop_count = hop_count
    
    def __repr__(self) -> str:
        return f"Self: {self.self_id}, moving speed: {self.self_moving_speed}, location: {self.self_location}, hop count: {self.hop_count}"

    def __eq__(self, __o: NodeInfo) -> bool:
        return self.self_id == __o.self_id \
                and self.self_moving_speed == __o.self_moving_speed \
                and self.self_location == __o.self_location \
                and self.hop_count == __o.hop_count
    
    def __hash__(self) -> int:
        return hash((self.self_id, self.self_moving_speed, self.self_location, self.hop_count))

class NodesTable():
    def __init__(self):
        self.nodes_list = {}
        
    def __repr__(self):
        result = ""
        for key, value in self.nodes_list.items():
            result += f"{key} : {value} \n" 
        return result

    def add_node(self, node: NodeInfo):
        if node.self_id not in self.nodes_list:
            self.nodes_list[node.self_id] = node
            printer.print_debug_colored(text=f"Drone {node.self_id} is inserted into the depot NodesTable with hop count {node.hop_count}")

        else:
            old: NodeInfo = self.nodes_list[node.self_id]
            if old.hop_count < node.hop_count:
                self.nodes_list[node.self_id] = node
                printer.print_debug_colored(text=f"NodesTable hop count for Drone {node.self_id} has changed from {old.hop_count} to {node.hop_count}")
    
    def __eq__(self, __o: object) -> bool:
        return self.nodes_list == __o.nodes_list

class NeighborTable():
    def __init__(self, simulator: Simulator, drone: Drone):
        self.drone = drone
        self.simulator = simulator
        self.neighbors_list = {}
    
    def __repr__(self):
        return str(self.neighbors_list)

    def add_node(self, node: NodeInfo, log=True):
        if node.self_id not in self.neighbors_list and node.self_id != self.drone.identifier:
            self.neighbors_list[node.self_id] = node
            if log:
                self.simulator.tester.print_neighborhood_flow(self.drone, node.self_id)
        if node.self_id in self.neighbors_list:
            old: NodeInfo = self.neighbors_list[node.self_id]
            if node.hop_count is not None and old.hop_count is not None:
                if old.hop_count < node.hop_count:
                    self.neighbors_list[node.self_id] = node
                    if log:
                        self.simulator.tester.print_neighborhood_flow(self.drone, node.self_id)
    
    def generate_update(self, new_neighbor_table: NeighborTable):
        result = NeighborTable(self.simulator, self.drone)
        for node_info in new_neighbor_table.neighbors_list.values():
            result.add_node(node_info, log=False)
        for node_info in self.neighbors_list.values():
            result.add_node(node_info, log=False)
        return result

    def update_own(self, new_neighbor_table: NeighborTable):
        node_info: NodeInfo
        for node_info in new_neighbor_table.neighbors_list.values():
            if utilities.euclidean_distance(self.simulator.drones[node_info.self_id].coords, self.drone.coords) <= self.drone.communication_range:
                self.add_node(node_info)

    def get_drones(self):
        return [self.simulator.drones[id] for id in self.neighbors_list.keys()]

# ------------------ Depot ----------------------
class Depot(Entity):
    """ The depot is an Entity. """

    def __init__(self, coords, communication_range, simulator):
        super().__init__(id(self), coords, simulator)
        self.communication_range = communication_range

        self.__buffer = list()  # also with duplicated packets

        self.nodes_table = NodesTable() #For discovery of the Multi-UAV nodes information in the whole network

    def all_packets(self):
        return self.__buffer

    def transfer_notified_packets(self, current_drone, cur_step):
        """ function called when a drone wants to offload packets to the depot """

        packets_to_offload = current_drone.all_packets()
        self.__buffer += packets_to_offload

        for pck in packets_to_offload:

            if self.simulator.routing_algorithm.name not in "GEO" "RND" "GEOS" "QLS":

                feedback = 1
                delivery_delay = cur_step - pck.event_ref.current_time

                for drone in self.simulator.drones:
                    drone.routing_algorithm.feedback(current_drone,
                                                     pck.event_ref.identifier,
                                                     delivery_delay,
                                                     feedback)

            #print(f"DEPOT -> Drone {current_drone.identifier} packet: {pck.event_ref} total packets in sim: {len(self.simulator.metrics.drones_packets_to_depot)}")
            # add metrics: all the packets notified to the depot
            self.simulator.metrics.drones_packets_to_depot.add((pck, cur_step))
            self.simulator.metrics.drones_packets_to_depot_list.append((pck, cur_step))

            pck.time_delivery = cur_step
    
    def get_children(self):
        """
        Gets the drones that have the depot has a parent
        """
        return [drone for drone in self.simulator.drones if drone.parent_node == self]\
    
    def has_children(self):
        """
        Returns True if the depot has children, False otherwise
        """
        return len(self.get_children()) != 0
    
    def get_chain(self):
        """
        Gets the chain of reachable drones from itself
        """
        chain = set()
        def get_chain_rec(entity: Drone|Depot):
            nonlocal chain
            if not entity.has_children():
                return
            chain = chain.union(set(entity.get_children()))
            child: Drone
            for child in entity.get_children():
                get_chain_rec(child)
        get_chain_rec(self)
        return chain
    
    def start_discovery(self):
        """
        Starts the network discovery.
        First sends the DiscoveryPacket to all the drones in the communication range;
        Then sends the signal to start the discovery on their own for the drones that are not in the depot communication range.
        """
        self.nodes_table = NodesTable()
        drone: Drone
        for drone in self.simulator.drones: #The first for is to send the DiscoveryPacket to the drones in the communication range
            drone_distance_to_depot = utilities.euclidean_distance(drone.coords, self.coords)
            if drone_distance_to_depot <= self.communication_range: #The drone is in the neighborhood of the depot
                discovery_packet = DiscoveryPacket(self, self.simulator)
                drone.nodes_discovery(discovery_packet) #Initialize the discovery process, setting the depot as the parent
        for drone in self.simulator.drones: #The second fore is to send the signal for the drones not in the communication range to start their own network discovery
            drone_distance_to_depot = utilities.euclidean_distance(drone.coords, self.coords)
            if drone_distance_to_depot <= self.simulator.depot_control_com_range: #The drone is in the range of the depot control packet range
                drone.initialize_discovery() #Initialize the discovery without setting the depot as the parent

    def update_nodes_table_by_ack(self, ack_packet: AckDiscoveryPacket):
        node_info = NodeInfo(ack_packet.self_id, ack_packet.self_moving_speed, ack_packet.self_location, ack_packet.hop_count)
        self.nodes_table.add_node(node_info)

    def update_nodes_table_by_neighbor_table(self, neighbor_table: NeighborTable):
        neighbor_info: NodeInfo
        for neighbor_info in neighbor_table.neighbors_list.values():
            node_info = NodeInfo(neighbor_info.self_id, neighbor_info.self_moving_speed, neighbor_info.self_location, neighbor_info.hop_count)
            self.nodes_table.add_node(node_info)


# ------------------ Drone ----------------------
class Drone(Entity):

    def __init__(self, identifier: int, path: list, depot: Depot, simulator):

        super().__init__(identifier, path[0], simulator)

        self.depot = depot
        self.path = path
        self.speed = self.simulator.drone_speed
        self.sensing_range = self.simulator.drone_sen_range
        self.communication_range = self.simulator.drone_com_range
        self.buffer_max_size = self.simulator.drone_max_buffer_size
        self.residual_energy = self.simulator.drone_max_energy
        self.come_back_to_mission = False  # if i'm coming back to my applicative mission
        self.last_move_routing = False  # if in the last step i was moving to depot
        self.BETA = 0.8 #Link stability constants

        # dynamic parameters
        self.tightest_event_deadline = None  # used later to check if there is an event that is about to expire
        self.current_waypoint = 0

        self.__buffer = []  # contains the packets

        self.distance_from_depot = 0
        self.move_routing = False  # if true, it moves to the depot

        # setup drone routing algorithm
        self.routing_algorithm = self.simulator.routing_algorithm.value(self, self.simulator)

        # drone state simulator

        # last mission coord to restore the mission after movement
        self.last_mission_coords = None

        #Neighbor_table
        self.neighbor_table = NeighborTable(self.simulator, self) #For discovery of the Multi-UAV nodes information in the neighbor network
        self.link_qualities = {}
        self.link_stabilities = [0 for _ in range(self.simulator.n_drones)]

        self.distance_vector = {} #{drone_i_j: [distance_i_j]}
        self.distance_vector_2 = [0 for _ in range(self.simulator.n_drones) for neighbor in range(self.simulator.n_drones)]

        self.parent_node: Drone | Depot = None

        self.hop_from_depot = None
    
    def compute_link_quality(self, cur_step):
        cur_link_qualities = []
        for j in self.simulator.drones: #For each drones
            #We compute the link quality between i (self.drone) and the other j drones that depends on the distance. We use an exponential decay function so the closer they are, the higher the quality.
            link_quality_ij = np.exp(-7*(utilities.euclidean_distance(self.coords, j.coords)/config.COMMUNICATION_RANGE_DRONE)) if self.identifier != j else 0
            cur_link_qualities.append(link_quality_ij) #We store the qualities between i and j
        self.link_qualities[cur_step] = cur_link_qualities
        while (len(self.link_qualities.keys()) > self.simulator.n_drones): #Since we need only the last n link qualities, we delete the others (saves a lot of memory!)
            min_step = np.min(list(self.link_qualities.keys()))
            del self.link_qualities[min_step]
    
    def sum_n_last_link_qualities(self, drone):
        #Since we keep only the last n link qualities computed in the link quality dictionary, we simply sum all link quality values for the given drone
        return sum([link_quality_by_step[drone.identifier] for link_quality_by_step in self.link_qualities.values()])

    def update_link_stability(self):
        link_quality_sum = {} #Stores the sum of link qualities in the last n steps (n is the number of drones) between the current drone and the others
        for j in self.neighbor_table.get_drones():
            #neighbor = self.simulator.drones[neighbor]
            link_quality_sum[j.identifier] = self.sum_n_last_link_qualities(j) #Sum the last n link qualities between the current_drone and the others (n is the number of drones)
            
            relative_speed_ij = self.compute_nodes_speed(self, j) #Compute the speed at which two nodes move away
        
            #Compute the link stability between the current drone and the neighbor. If the relative speed is None it means we are in the first step so we don't consider it during the link stability computation
            link_stability_ij = link_quality_sum[j.identifier]/len(self.neighbor_table.neighbors_list) if relative_speed_ij == None else (1-self.BETA)*np.exp(1/relative_speed_ij)+self.BETA*(link_quality_sum[j.identifier]/len(self.neighbor_table.neighbors_list))

            self.link_stabilities[j.identifier] = link_stability_ij #Update the link stability between current_drone and the drone j
            
    #compute the speed at which nodes 𝑖 and 𝑗 are moving away, equals the change in distance between them divided by the change in time
    def compute_nodes_speed(self, drone_i, drone_j):
        # Our solution (☭)
        # Ad ogni step, durante il calcolo della link stability, per ogni nodo vicino (j) al drone corrente (i) vado a calcolarmi una sorta di velocitá relativa in questo modo:
        # 1.	Utilizzo le coordinate della posizione corrente e le coordinate fornite da next_target del nodo i e j per capire in che direzione stanno procedendo.
        # 2.	Successivamente in base a questa direzione e alla loro DRONE_SPEED trovo le coordinate del punto che ogni drone raggiungerá al prossimo step (una sorta di next_step compreso nel percorso che parte da cur_pos e next_target).
        # 3.	A questo punto avró un vettore per ogni drone con due coordinate ([cur_pos], [next_step]), li chiameremo rispettivamente dist_i e dist_j.
        # 4.	Li sommiamo entrambi ottenendo la distanza percorsa in quello step da entrambi i droni.
        # 5.	Infine calcoliamo la velocitá relativa in questo modo: velocitá = distanza appena calcolata / tempo (inteso come time_step_duration)
        # 
        # La velocitá ottenuta, secondo il nostro ragionamento, dovrebbe essere compresa tra 0 (se i nodi si stanno muovendo nella stessa direzione) e 2*DRONE_SPEED (se vanno in direzioni opposte).
        
        # Flavio's solution :)
        # Vorreste calcolare la velocità relativa dei due punti calcolando la posizione corrente di entrambe i punti e misurando la distanza che c'è tra i due punti.
        # Dopo un delta t vi ricalcolate la posizione corrente dei punti e misurate la distanza che c'è.
        # A questo punto potete prendere la differenza nella distanza dei punti a tempo t e t + delta e dividerla per il delta e dovreste ottenere la velocità relativa.
        identifier = str(drone_i.identifier) + "_" + str(drone_j.identifier)
        if identifier not in self.distance_vector:
            cur_distance = utilities.euclidean_distance(drone_i.coords, drone_j.coords)
            self.distance_vector[identifier] = cur_distance

            return None
        else:
            old_distance = self.distance_vector[identifier]
            cur_distance = utilities.euclidean_distance(drone_i.coords, drone_j.coords)
            self.distance_vector[identifier] = cur_distance

            cur_speed = abs(old_distance - cur_distance) / config.TS_DURATION
        
        """
        print(cur_speed)
        neighbor = drone_j
        if self.simulator.cur_step > 1:
            old_distance = self.distance_vector_2[neighbor.identifier]
            cur_distance = utilities.euclidean_distance(self.coords, neighbor.coords)
            cur_speed_2 = abs(old_distance - cur_distance) / config.TS_DURATION
            self.distance_vector_2[neighbor.identifier] = cur_distance
            print(cur_speed_2)
        else:
            cur_distance = utilities.euclidean_distance(self.coords, neighbor.coords)
            self.distance_vector_2[neighbor.identifier] = cur_distance
            print(cur_speed_2)
        """

        return cur_speed
    
    def set_hop_from_depot(self, new_hop, message=""):
        """
        Change hop count to another hop count.
        Message: str -- The message that caused the hop change, useful for debug reasons.
        """
        self.simulator.tester.print_hop_update(self, new_hop, message)
        self.hop_from_depot = new_hop

    def initialize_discovery(self):
        """
        Send the DiscoveryPacket to the drones in the neighborhood, it's initialized by the Depot.
        """
        neighbors = [drone for drone in self.simulator.drones if utilities.euclidean_distance(self.coords, drone.coords) <= self.communication_range and self != drone] # Calculate the drones in its neighborhood
        drone: Drone
        for drone in neighbors:
            discovery_packet = DiscoveryPacket(self, self.simulator, hop_count=None)
            drone.nodes_discovery(discovery_packet)
 
    def nodes_discovery(self, discovery_packet: DiscoveryPacket):
        """
        Does the network discovery, in order to get the neighbor list and in order to send the depot all the nodes that are connected to it through some chain of drones.
        """

        def just_consider_it(sender: Drone, receiver: Drone):
            """
            When a sender sends the DiscoveryPacket to a receiver, it means that both the drones are in their communication range, so without caring about anything else, they both add each
            other to their neighbor table. The receiver sends an ack to the sender to let it know that it's in its communication range, and adds the sender to its neighbor table.
            """
            receiver.send_ack_unicast(AckDiscoveryPacket(sender.identifier, receiver.identifier, receiver.speed, receiver.coords,discovery_packet.hop_count, receiver.simulator), sender)
            node_info = NodeInfo(sender.identifier, sender.speed, sender.coords, sender.hop_from_depot)
            receiver.neighbor_table.add_node(node_info)

        self.simulator.tester.print_send_dp(discovery_packet.entity, self)
        if discovery_packet.entity != self.simulator.depot:
            just_consider_it(discovery_packet.entity, self)
        """
        Manage the reception of a DiscoveryPacket if it's the first that the drone receives
        - Sets the parent as the entity that sent it the DiscoveryPacket
        - Broadcasts the DiscoveryPacket to the drones in its neighborhood\

        If hop_count = None, then the drone is receiving the packet from another Drone that is not linked with the depot
        If discovery_packet.entity == Depot and hop_count = None, then the Drone it's locally initializing the discovery, because it has received the packet from the Depot with Long Range communication.
        """
        if discovery_packet.hop_count is not None and self.parent_node is not None:
            self.update_parent(new_parent= discovery_packet.entity, new_hop_count= discovery_packet.hop_count)
            return

        if self.parent_node is not None: #The delivery packet arrives from a drone that's not connected to the Depot, since hop_count = None.
            return # Ignore it since the drone already has received a DiscoveryPacket from another drone and there is no need to update the hop_count 

        if self.has_children() and discovery_packet.hop_count is None: #This is needed in order to avoid cycles of father and child relationship between blobs of non-connected drones.
            return # Ignore the packet otherwise the drone will close the loop
        
        # #TODO: In theory this should work and the one above should cause a loop, but they both work fine, so since the one above it's more computational efficient I use that one.
        # I leave this in case it's needed.
        # if discovery_packet.entity in self.get_chain() and discovery_packet.hop_count is None:
        #     return 

        self.simulator.tester.print_receive_dp(discovery_packet.entity, self)

        #The code below runs only if self.parent_node is None (it's the first time that the drone has ever received a DiscoveryPacket)
        self.parent_node = discovery_packet.entity

        # Add the parent node to the neighbor list
        if self.parent_node != self.simulator.depot:
            parent_node_info = NodeInfo(self.parent_node.identifier, self.parent_node.speed, self.parent_node.coords, self.parent_node.hop_from_depot)
            self.neighbor_table.add_node(parent_node_info)

        self.set_hop_from_depot(discovery_packet.hop_count, message=f"First time received a Discovery Packet from {discovery_packet.entity}")
        ## GenerateAck + Unicast(Ack, Parent_node)
        ack_packet = AckDiscoveryPacket(self.parent_node.identifier, self.identifier, self.speed, self.coords, discovery_packet.hop_count, self.simulator)
        self.send_ack_unicast(ack_packet, self.parent_node) #Sends the ack to the parent node
        self.update_nodes_table_by_neighbor_table(self.neighbor_table) #Updates the parent node's nodes table with the drone's neighbor table
        # Modify Discovery_packet:
        new_discovery_packet = DiscoveryPacket(self, self.simulator, self.hop_from_depot)
        #Broadcast(Discovery_packet)

        drone: Drone #Type hints for auto-completion in for-loop
        for drone in self.simulator.drones:
            if drone not in [self, self.parent_node]:
                self_distance_to_drone = utilities.euclidean_distance(new_discovery_packet.entity.coords, drone.coords)
                if self_distance_to_drone <= self.communication_range:
                    drone.nodes_discovery(new_discovery_packet)
                self.update_nodes_table_by_neighbor_table(self.neighbor_table)
    
    def get_children(self):
        """
        Gets the node that has self has a parent
        """
        return [drone for drone in self.simulator.drones if drone.parent_node == self]
    
    def has_children(self):
        """
        Returns True if self has children, False otherwise
        """
        return len(self.get_children()) != 0
    
    def get_chain(self):
        """
        Gets the chain of reachable drones from self
        """
        chain = set()
        def get_chain_rec(drone: Drone):
            nonlocal chain
            if not drone.has_children():
                return
            chain = chain.union(set(drone.get_children()))
            child: Drone
            for child in drone.get_children():
                get_chain_rec(child)
        get_chain_rec(self)
        return chain
    
    def update_newest_hop_count(self, new_hop_count, new_parent):
        """
        Updates the hop count of all the rest of the nodes that are in the drone's tree of neighbors.
        """
        printer.print_debug_colored(0, 200, 0, f"Updating {self} from {new_parent}, new hop count: {new_hop_count}, old hop count: {self.hop_from_depot}")
        self.set_hop_from_depot(new_hop_count, message=f"Updating newer hop count from {new_parent}")

        #Send back the updated information about the new hop_count from the depot
        uptodate_neighbor_table = NeighborTable(self.simulator, self)
        new_node_info = NodeInfo(self.identifier, self.speed, self.coords, self.hop_from_depot)
        uptodate_neighbor_table.add_node(new_node_info)
        new_neighbor_table = self.neighbor_table.generate_update(uptodate_neighbor_table)
        self.parent_node.update_nodes_table_by_neighbor_table(new_neighbor_table) 

        children = self.get_children()
        child: Drone
        for child in children:
            child.update_newest_hop_count(self.hop_from_depot+1, self)
    
    def update_hop_count_bridge(self, hop_count_bridge):
        """
        If the node self has a hop_count = None it means it's disconnected. 
        In case anotehr drone with hop_count != None sends a DiscoveryPacket to self, it means that self can connect to the depot using the new drone as a bridge.
        The function updates the hop_counts of self and all its children.
        """
        self.set_hop_from_depot(hop_count_bridge + 1, message=f"Bridging")
        #Send back the updated information about the new hop_count from the depot
        uptodate_neighbor_table = NeighborTable(self.simulator, self)
        new_node_info = NodeInfo(self.identifier, self.speed, self.coords, self.hop_from_depot)
        uptodate_neighbor_table.add_node(new_node_info)
        new_neighbor_table = self.neighbor_table.generate_update(uptodate_neighbor_table)
        self.parent_node.update_nodes_table_by_neighbor_table(new_neighbor_table) 

        children = self.get_children()
        child: Drone
        for child in children:
            if child.hop_from_depot is None :
                child.update_hop_count_bridge(self.hop_from_depot)
    
    def update_parent(self, new_parent, new_hop_count):
        """
        If the drone receives a DiscoveryPacket with a lower hop count, then it updates its parent and recursively
        the hop count of all the rest of the nodes that are in its tree of neighbors.
        """
        old_hop_count = self.hop_from_depot
        if old_hop_count == None: #The drone wasn't connected to the depot, but know there is a drone that connects it
            self.update_hop_count_bridge(new_hop_count) #Update all the children
            return
        if new_hop_count < old_hop_count: #The hop count is lower, so it's necessary to update it
            self.parent_node = new_parent
            self.update_newest_hop_count(new_hop_count, new_parent)
            

    def send_ack_unicast(self, ack_packet: AckDiscoveryPacket, parent_node: Drone | Depot):
        self.simulator.tester.add_ack(ack_packet, parent_node)
        parent_node.update_nodes_table_by_ack(ack_packet)
    
    def update_nodes_table_by_neighbor_table(self, neighbor_table: NeighborTable):
        """
        Generates a new neighbor table that's the union between the incoming one and the stored one.
        It then unicast the new neighbor table to the parent node.
        This is needed in order for the depot to receive all the cumulative neighbor tables that were sended between the drones
        in order to know which are the drones connected to the depot.
        """
        if self.parent_node is not None:
            new_neighbor_table = self.neighbor_table.generate_update(neighbor_table)
            self.parent_node.update_nodes_table_by_neighbor_table(new_neighbor_table)

        self.neighbor_table.update_own(neighbor_table)
    
    def update_nodes_table_by_ack(self, ack_packet: AckDiscoveryPacket):
        node_info = NodeInfo(ack_packet.self_id, ack_packet.self_moving_speed, ack_packet.self_location, ack_packet.hop_count)
        self.neighbor_table.add_node(node_info)    

    def reset_discovery_state(self):
        self.parent_node = None
        self.set_hop_from_depot(None, message="Resetting discovery state")
        self.neighbor_table = NeighborTable(self.simulator, self)

    def reset_neighbors_table(self):
        self.neighbor_table = NeighborTable(self.simulator)
    
    def compute_reward(self):
        if self.simulator.routing_algorithm.name == "QLS":
            for drone in self.simulator.drones:
                drone.routing_algorithm.compute_reward(self)

    def update_packets(self, cur_step):
        """
        Removes the expired packets from the buffer

        @param cur_step: Integer representing the current time step
        @return:
        """
        to_remove_packets = 0
        tmp_buffer = []
        self.tightest_event_deadline = np.nan

        for pck in self.__buffer:
            if not pck.is_expired(cur_step):
                tmp_buffer.append(pck)  # append again only if it is not expired
                self.tightest_event_deadline = np.nanmin([self.tightest_event_deadline, pck.event_ref.deadline])

            else:

                to_remove_packets += 1

                if self.simulator.routing_algorithm.name not in "GEO" "RND" "GEOS" "QLS":

                    feedback = -1
                    current_drone = self

                    for drone in self.simulator.drones:
                        drone.routing_algorithm.feedback(current_drone,
                                                         pck.event_ref.identifier,
                                                         self.simulator.event_duration,
                                                         feedback)

        self.__buffer = tmp_buffer

        if self.buffer_length() == 0:
            self.move_routing = False

    def packet_is_expiring(self, cur_step):
        """ return true if exist a packet that is expiring and must be returned to the depot as soon as possible
            -> start to move manually to the depot.

            This method is optional, there is flag src.utilities.config.ROUTING_IF_EXPIRING
        """
        time_to_depot = self.distance_from_depot / self.speed
        event_time_to_dead = (self.tightest_event_deadline - cur_step) * self.simulator.time_step_duration
        return event_time_to_dead - 5 < time_to_depot <= event_time_to_dead  # 5 seconds of tolerance

    def next_move_to_mission_point(self):
        """ get the next future position of the drones, according the mission """
        current_waypoint = self.current_waypoint
        if current_waypoint >= len(self.path) - 1:
            current_waypoint = -1

        p0 = self.coords
        p1 = self.path[current_waypoint + 1]
        all_distance = utilities.euclidean_distance(p0, p1)
        distance = self.simulator.time_step_duration * self.speed
        if all_distance == 0 or distance == 0:
            return self.path[current_waypoint]

        t = distance / all_distance
        if t >= 1:
            return self.path[current_waypoint]
        elif t <= 0:
            print("Error move drone, ratio < 0")
            exit(1)
        else:
            return ((1 - t) * p0[0] + t * p1[0]), ((1 - t) * p0[1] + t * p1[1])

    def feel_event(self, cur_step):
        """
        feel a new event, and adds the packet relative to it, in its buffer.
            if the drones is doing movement the packet is not added in the buffer
         """

        ev = Event(self.coords, cur_step, self.simulator)  # the event
        pk = ev.as_packet(cur_step, self)  # the packet of the event
        if not self.move_routing and not self.come_back_to_mission:
            self.__buffer.append(pk)
            self.simulator.metrics.all_data_packets_in_simulation += 1
        else:  # store the events that are missing due to movement routing
            self.simulator.metrics.events_not_listened.add(ev)

    def accept_packets(self, packets):
        """ Self drone adds packets of another drone, when it feels it passing by. """

        for packet in packets:
            # add if not notified yet, else don't, proprietary drone will delete all packets, but it is ok
            # because they have already been notified by someone already

            if not self.is_known_packet(packet):
                self.__buffer.append(packet)

    def routing(self, drones, depot, cur_step):
        """ do the routing """
        self.distance_from_depot = utilities.euclidean_distance(self.depot.coords, self.coords)
        self.routing_algorithm.routing(depot, drones, cur_step)

    def move(self, time):
        """ Move the drone to the next point if self.move_routing is false, else it moves towards the depot. 
        
            time -> time_step_duration (how much time between two simulation frame)
        """
        if self.move_routing or self.come_back_to_mission:
            # metrics: number of time steps on active routing (movement) a counter that is incremented each time
            # drone is moving to the depot for active routing, i.e., move_routing = True
            # or the drone is coming back to its mission
            self.simulator.metrics.time_on_active_routing += 1

        if self.move_routing:
            if not self.last_move_routing:  # this is the first time that we are doing move-routing
                self.last_mission_coords = self.coords

            self.__move_to_depot(time)
        else:
            if self.last_move_routing:  # I'm coming back to the mission
                self.come_back_to_mission = True

            self.__move_to_mission(time)

            # metrics: number of time steps on mission, incremented each time drone is doing sensing mission
            self.simulator.metrics.time_on_mission += 1

        # set the last move routing
        self.last_move_routing = self.move_routing

    def is_full(self):
        return self.buffer_length() == self.buffer_max_size

    def is_known_packet(self, packet: DataPacket):
        """ Returns True if drone has already a similar packet (i.e., referred to the same event).  """
        for pk in self.__buffer:
            if pk.event_ref == packet.event_ref:
                return True
        return False

    def empty_buffer(self):
        self.__buffer = []

    def all_packets(self):
        return self.__buffer

    def buffer_length(self):
        return len(self.__buffer)

    def remove_packets(self, packets):
        """ Removes the packets from the buffer. """
        for packet in packets:
            if packet in self.__buffer:
                self.__buffer.remove(packet)
                if config.DEBUG:
                    print("ROUTING del: drone: " + str(self.identifier) + " - removed a packet id: " + str(
                        packet.identifier))

    def next_target(self):
        if self.move_routing:
            return self.depot.coords
        elif self.come_back_to_mission:
            return self.last_mission_coords
        else:
            if self.current_waypoint >= len(self.path) - 1:  # reached the end of the path, start back to 0
                return self.path[0]
            else:
                return self.path[self.current_waypoint + 1]

    def __move_to_mission(self, time):
        """ When invoked the drone moves on the map. TODO: Add comments and clean.
            time -> time_step_duration (how much time between two simulation frame)
        """
        if self.current_waypoint >= len(self.path) - 1:
            self.current_waypoint = -1

        p0 = self.coords
        if self.come_back_to_mission:  # after move
            p1 = self.last_mission_coords
        else:
            p1 = self.path[self.current_waypoint + 1]

        all_distance = utilities.euclidean_distance(p0, p1)
        distance = time * self.speed
        if all_distance == 0 or distance == 0:
            self.__update_position(p1)
            return

        t = distance / all_distance
        if t >= 1:
            self.__update_position(p1)
        elif t <= 0:
            print("Error move drone, ratio < 0")
            exit(1)
        else:
            self.coords = (((1 - t) * p0[0] + t * p1[0]), ((1 - t) * p0[1] + t * p1[1]))

    def __update_position(self, p1):
        if self.come_back_to_mission:
            self.come_back_to_mission = False
            self.coords = p1
        else:
            self.current_waypoint += 1
            self.coords = self.path[self.current_waypoint]

    def __move_to_depot(self, time):
        """ When invoked the drone moves to the depot. TODO: Add comments and clean.
            time -> time_step_duration (how much time between two simulation frame)
        """
        p0 = self.coords
        p1 = self.depot.coords

        all_distance = utilities.euclidean_distance(p0, p1)
        distance = time * self.speed
        if all_distance == 0:
            self.move_routing = False
            return

        t = distance / all_distance

        if t >= 1:
            self.coords = p1  # with the next step you would surpass the target
        elif t <= 0:
            print("Error routing move drone, ratio < 0")
            exit(1)
        else:
            self.coords = (((1 - t) * p0[0] + t * p1[0]), ((1 - t) * p0[1] + t * p1[1]))

    def __repr__(self):
        return "Drone " + str(self.identifier)

    def __hash__(self):
        return hash(self.identifier)


# ------------------ Environment ----------------------
class Environment(SimulatedEntity):
    """ The environment is an entity that represents the area of interest on which events are generated.
     WARNING this corresponds to an old view we had, according to which the events are generated on the map at
     random and then maybe felt from the drones. Now events are generated on the drones that they feel with
     a certain probability."""

    def __init__(self, width, height, simulator):
        super().__init__(simulator)

        self.depot = None
        self.drones = None
        self.width = width
        self.height = height

        self.event_generator = EventGenerator(height, width, simulator)
        self.active_events = []

    def add_drones(self, drones: list):
        """ add a list of drones in the env """
        self.drones = drones

    def add_depot(self, depot: Depot):
        """ add depot in the env """
        self.depot = depot

class EventGenerator(SimulatedEntity):

    def __init__(self, height, width, simulator):
        """ uniform event generator """
        super().__init__(simulator)
        self.height = height
        self.width = width

    def uniform_event_generator(self):
        """ generates an event in the map """
        x = self.simulator.rnd_env.randint(0, self.height)
        y = self.simulator.rnd_env.randint(0, self.width)
        return x, y

    def poisson_event_generator(self):
        """ generates an event in the map """
        pass
